# core data 笔记 

> objc.io Core Data

## 可选值的约定

Swift 提供了 Optional 数据类型,这迫使我们显式地思考和处理没有值的情况
避免使用 Swift 的 ! 操作符来强制解包
唯一的例外是那些必须设置但又无法在初始化时设置的属性。比如 Interface Builder 的 outlets 或必要的代理 (delegate) 属性等。在这些情况下,使用隐式解包的可选值符合 “尽早崩 溃” 原则
## 错误处理的约定
Core Data 中好些方法会抛出错误。基于它们是不同类型的错误的这一基本事实,我们可以分 类处理这些错误。我们将区分逻辑错误和其他错误。
逻辑错误是指程序员犯错的结果。它们应该从代码层面上修复而不应该尝试动态恢复程序的运
行。

一个例子,当你尝试读取应用程序包里的一个文件的时候,因为应用程序包是只读的,那么一
个文件要么存在要么不存在,而且它的内容永远不会变。所以如果我们无法打开或者解析应用
程序包里的文件,这就是一个逻辑错误。

对于这些类型的错误,我们使用 Swift 的 try ! 或 fatalError () 来尽可能早地让应用程序崩溃。

同样的思想可以适用于 as! 操作符的强制类型转换: 如果我们知道一个对象必须是某种类型,转
换失败的唯一原因会是逻辑错误,这种时候我们实际上是希望应用程序崩溃的。
很多时候我们用 Swift 的 guard 关键字来更好地表达哪些地方出错了。例如 fetched results controller 返回的类型是 NSManagedObject 的对象,我们知道它必须是一个特定的子类,我 们使用 guard 来保证向下转换,并在出错的时候使用 fatal error 来终止程序:
````swift
func objectAtIndexPath(indexPath: NSIndexPath) -> Object {
	guard let result = fetchedResultsController.objectAtIndexPath(indexPath) as? Object else
	{
		fatalError("Unexpected object at \(indexPath)")
	}
	return result
}
````
## 数据建模
### 实体与属性
Core Data 自身就支持很多数据类型:数值类型 (整数和不同大小的浮点数,以及十进制数值), 字符串,布尔值,日期,二进制数据,__以及存储着实现了 NSCoding 协议的对象或者是提供了 自定义值转换器 (value transformer) 的对象的可转换类型。__
### 属性选项

- 可选属性


- 必选属性
  必选属性必须要赋给它们恰当的值,才能保存这些数据。把一个属性标记为可索引时,Core Data 会在底层 SQLite 数据库表里创建一个索引。索引可以加速这个属性的搜索和排序,但代 价是插入数据时的性能下降和额外的存储空间。在我们的例子里,我们会以 mood 对象的时间 来排序,所以把 date 属性标记为可索引是有意义的。我们后面会在性能和性能分析这些章节里深入探讨这个主题。

### 托管对象子类
__我们建议不要使用 Xcode 的代码生成工具，直接手写它们__
- 好处是 __每次只需要写很少几行代码,就能带来完全掌控它们的好处。此外,手写代码还会让整个流程 变得更加清楚,你会发现其中并没有什么魔法__

> 研习源码代码
> - 通过创建一些简单的辅助方法,能在插入对象、执行获取请求、或是执行类似重复的任 务的时候让你的生活变得轻松一点。
> - 把数据源和fetchedresultscontroller的代理方法封装到分离的类里,这样有助于代码 复用,保持 view controller 精简,也更符合 Swift 的类型安全特性。


## 关系
###子实体
- __避免使用子实体__ 原因：Core Data 将不得不从一个巨 大的数据库表里读取所有数据,所以这很快会成为一个性能和内存的问题 (如果你不熟悉关系 型数据库的结构
- 要是把拥 有共同父实体的所有实体合并成一个带有类型属性的单一实体的感觉会不会非常糟糕?如果是, 那么你就不应该使用子实体。
- 除非你需要在相同的获取请求结果或者同一个关系里得到多种类型的对象,否则最好还是避免 使用子实体。需要注意的是,多个类继承一个相同的父类,而又不把它们变成相同实体的子实 体的做法是完全可以接受的。但是在 Swift 里,使用一个共同的协议而不是子类化的做法可能 会更好。

### 关系其他使用场景
- 只有在你完全确信你永远不会删除一个缺少反向关系的对象时才考虑使用单向关系
  > 考 虑这个例子:我们有 Message 和 User 两种实体,它们是通过从 Message 到 User 的一个叫 sender 的 “对一” 关系联系起来的。如果我们百分百确信我们永远不会删除 User 对象,那么我 们可以考虑省去从 User 到 Message 的反向关系 messages 来避免更新这个关系的开销,反正 我们永远不会使用它。但要注意,这可能是一个典型的过早优化 (premature optimization) 的 例子 — 一定要首先检查这个关系是否真的会导致性能问题,再决定是否要做出这样的优化。

###建立关系
1. 在内存中查找相关联的对象 
````swift
	managerobjectContext.registeredObjects
````
1. 对象不在内存中在进行查询 ````fetchRequest````
### 关系删除规则
- nullify  删除规则会把被删除的对象从它的反向关系里移除
- cascade 删除规则会删除相关联的对象们
- deny 删除规则可以防止关系不为空的对象被删除
- no action Core Data 不会更 新反向关系 (们),而是由我们开发者向 Core Data 保证我们已经准备好了更新它们的自定义代 码。
### 自定义删除规则
通过实现 ````prepareForDeletion()````