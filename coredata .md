# core data 笔记 

> objc.io Core Data

## 可选值的约定

Swift 提供了 Optional 数据类型,这迫使我们显式地思考和处理没有值的情况
避免使用 Swift 的 ! 操作符来强制解包
唯一的例外是那些必须设置但又无法在初始化时设置的属性。比如 Interface Builder 的 outlets 或必要的代理 (delegate) 属性等。在这些情况下,使用隐式解包的可选值符合 “尽早崩 溃” 原则
## 错误处理的约定
Core Data 中好些方法会抛出错误。基于它们是不同类型的错误的这一基本事实,我们可以分 类处理这些错误。我们将区分逻辑错误和其他错误。
逻辑错误是指程序员犯错的结果。它们应该从代码层面上修复而不应该尝试动态恢复程序的运
行。

一个例子,当你尝试读取应用程序包里的一个文件的时候,因为应用程序包是只读的,那么一
个文件要么存在要么不存在,而且它的内容永远不会变。所以如果我们无法打开或者解析应用
程序包里的文件,这就是一个逻辑错误。

对于这些类型的错误,我们使用 Swift 的 try ! 或 fatalError () 来尽可能早地让应用程序崩溃。

同样的思想可以适用于 as! 操作符的强制类型转换: 如果我们知道一个对象必须是某种类型,转
换失败的唯一原因会是逻辑错误,这种时候我们实际上是希望应用程序崩溃的。
很多时候我们用 Swift 的 guard 关键字来更好地表达哪些地方出错了。例如 fetched results controller 返回的类型是 NSManagedObject 的对象,我们知道它必须是一个特定的子类,我 们使用 guard 来保证向下转换,并在出错的时候使用 fatal error 来终止程序:
````swift
func objectAtIndexPath(indexPath: NSIndexPath) -> Object {
	guard let result = fetchedResultsController.objectAtIndexPath(indexPath) as? Object else
	{
		fatalError("Unexpected object at \(indexPath)")
	}
	return result
}
````
## 数据建模
### 实体与属性
Core Data 自身就支持很多数据类型:数值类型 (整数和不同大小的浮点数,以及十进制数值), 字符串,布尔值,日期,二进制数据,__以及存储着实现了 NSCoding 协议的对象或者是提供了 自定义值转换器 (value transformer) 的对象的可转换类型。__
### 属性选项

- 可选属性


- 必选属性
  必选属性必须要赋给它们恰当的值,才能保存这些数据。把一个属性标记为可索引时,Core Data 会在底层 SQLite 数据库表里创建一个索引。索引可以加速这个属性的搜索和排序,但代 价是插入数据时的性能下降和额外的存储空间。在我们的例子里,我们会以 mood 对象的时间 来排序,所以把 date 属性标记为可索引是有意义的。我们后面会在性能和性能分析这些章节里深入探讨这个主题。

### 托管对象子类
__我们建议不要使用 Xcode 的代码生成工具，直接手写它们__
- 好处是 __每次只需要写很少几行代码,就能带来完全掌控它们的好处。此外,手写代码还会让整个流程 变得更加清楚,你会发现其中并没有什么魔法__

> 研习源码代码
> - 通过创建一些简单的辅助方法,能在插入对象、执行获取请求、或是执行类似重复的任 务的时候让你的生活变得轻松一点。
> - 把数据源和fetchedresultscontroller的代理方法封装到分离的类里,这样有助于代码 复用,保持 view controller 精简,也更符合 Swift 的类型安全特性。


## 关系
###子实体
- __避免使用子实体__ 原因：Core Data 将不得不从一个巨 大的数据库表里读取所有数据,所以这很快会成为一个性能和内存的问题 (如果你不熟悉关系 型数据库的结构
- 要是把拥 有共同父实体的所有实体合并成一个带有类型属性的单一实体的感觉会不会非常糟糕?如果是, 那么你就不应该使用子实体。
- 除非你需要在相同的获取请求结果或者同一个关系里得到多种类型的对象,否则最好还是避免 使用子实体。需要注意的是,多个类继承一个相同的父类,而又不把它们变成相同实体的子实 体的做法是完全可以接受的。但是在 Swift 里,使用一个共同的协议而不是子类化的做法可能 会更好。

### 关系其他使用场景
- 只有在你完全确信你永远不会删除一个缺少反向关系的对象时才考虑使用单向关系
  > 考 虑这个例子:我们有 Message 和 User 两种实体,它们是通过从 Message 到 User 的一个叫 sender 的 “对一” 关系联系起来的。如果我们百分百确信我们永远不会删除 User 对象,那么我 们可以考虑省去从 User 到 Message 的反向关系 messages 来避免更新这个关系的开销,反正 我们永远不会使用它。但要注意,这可能是一个典型的过早优化 (premature optimization) 的 例子 — 一定要首先检查这个关系是否真的会导致性能问题,再决定是否要做出这样的优化。

###建立关系
1. 在内存中查找相关联的对象 
````swift
	managerobjectContext.registeredObjects
````
1. 对象不在内存中在进行查询 ````fetchRequest````
### 关系删除规则
- nullify  删除规则会把被删除的对象从它的反向关系里移除
- cascade 删除规则会删除相关联的对象们
- deny 删除规则可以防止关系不为空的对象被删除
- no action Core Data 不会更 新反向关系 (们),而是由我们开发者向 Core Data 保证我们已经准备好了更新它们的自定义代 码。
### 自定义删除规则
通过实现 ````prepareForDeletion()````
## 数据类型
二进制数据类型 应当单独列一个表可以加快效率
Core Data 支持所谓的__外部存储___,底层的 SQLite 可以直接在数据库里高效地存储不超过大概 100 kb 的二进制数据。一般来说这个选项通常都应该被开启
### 原始属性和临时属性
- 原始属性
  为了能在我们的自定义类里使用这些属性,我们必须用相同的 @NSManaged 属性来声明它们。你也应该总是给这些声明加上 private 关键字,因为原始属 性是特定托管对象子类的实现细节。原始属性基本是作为 Core Data 属性背后的存储而存在的。除了实现你自己的自定义存取方法 之外,你不应该直接访问它们
- 临时属性
  临时属性是指不会被持久化的属性。临时属性的数据在托管对象变成惰值或者生命周期结束时 会被丢弃掉。你可以在 Data Model Inspector 里将任意属性标记为临时属性,这会把它变成一 个只在内存里存在的属性。在你的托管对象子类里,如果需要额外而又非持久化的属性,那么你应该总是使 用临时属性。当然,这并不适用于计算属性 (computed properties) 这种没有实际存储的属性。
### 自定义数据类型
遵循 NSCoding 协议的数据类型都可以直接声明为可转换的属性。不过,你也可以指定一个自定义值转换器 (value transformer) 来用更高效的格式存储你的数据。
遵循 NSCoding 协议,我们只是简单地使用了可转换的属性。因为这些 数据会被保存为 plist 格式,所以这种方法的缺点是会浪费很多数据库空间,另外它也不是最高
效的实现。
#### 转换器的实现
继承`NSValueTransformer` 实现自己的转换器 再在数据库设计文件中打开 转换器
#### 自定义存取方法
当实现自定义存取方法时,总是记住使用`willAccess.../didAccess...`或 `willChange.../didChange...` 方法来包装对原始属性的访问。
###默认值和可选值
- 所有数据类型的属性都可以设置默认值。Core Data 会在一个对象被插入到上下文时自动将属 性设置为这个值。确保对象在开始时具有合法的值会非常有用,如果再能和 Swift 里的非 Optional 值相结合的话,那就会更有用了
- 你还可以在运行时设置默认值 覆盖`NSManagerObject` 类的` awakeFromInsert()` 方法
- awakeFromInsert() 方法在对象的生命周期里只会被调用一次